# ARGOMENTI:
- esempi di cpu
- esempi di bus
- interfacce il troughput può essere una unità di misura per capire quanto è veloce il processore e può misurare ogni componente che svolge la funzione nella pipeline

# ESEMPI DI CPU:
## Pentium 4
- 3.2 Ghz
- 90nm
-  può accedere a memorie a 64 bit viene programmata a 32 bit
- ha 3 livelli di cache
        1. 8kb di SRAM
        2. fino a 1mb
        3. da 2 MB.
        
Visto che ha due CPU potrebbe accadere un problema: se una CPU modifica una parola nella sua cache locale, l’altra avrà una versione "vecchia"; perciò avviene il processo di monitoraggio detto **snooping**, che permette alla CPU di tenere traccia delle modifiche che ha fatto. 
Quindi la CPU quando entra nel bus della memoria cercando qualcosa che è stato modificato, l'altra CPU procede a inviargliela aggiornato.

**Altre caratteristiche**:
- pipeline più profonda
- due unità ALU che che operano al doppio della frequenza di clock

Il problema delle CPU è che utilizzano troppa energia, perciò intel ha trovato un modo per metterle in idle e farle consumare meno.
Questa tecnologia divide il funzionamento della CPU in 5 livelli da attivo a sonno profondo; più si va verso il livello di sonno profondo più si perdono funzionalità come lo snooping e l’interrupt handling; quando la CPU va in sonno profondo rimangono attivi solo il registro e la cache e la CPU attende un interrupt hardware per risvegliarsi.

## Pin e segnali del Pentium4
La CPU ha diversi pin (478) e sono spartiti a seconda di diversi compiti:
- alcuni per i segnali di I/O, wait, interrupt;
- altri per l’alimentazione a diversi voltaggi;
- altri ancora per la massa;
- la intel si lascia qualche pin libero per un uso futuro;

## I PIN DEL PENTIUM 4
### ARBITRO DEL BUS
- **BPRI**# bus, priority request
- **BR0**#, bus request
- **LOCK**#, la CPU chiede all’arbitro del bus per bloccarla e permetterne l’utilizzo solo della CPU

## PIN DI RICHIESTA
Segnali scambiati con l’address bus e il bus di controllo
- **A**#, trasferimento di bit di indirizzamento ha 36 bit di indirizzamento di cui 3 impostati a 0
- **ADS**#, si asserisce se l’indirizzo inserito sul bus è valido
- **REQ**#, Specifica l’operazione di lettura o scrittura

## PIN DI ERRORI
- **MISC** è un segnale di errore generico che serve per segnalare se c’è un errore

## PIN DI RISPOSTA
Sono dei pin che usa il bus slave per comunicare con il bus master
- **RS**#, contiene il codice di stato, ovvero un codice che mostra lo stato corrente della CPU o del processo che sta eseguento
- **TRDY**#, indica che lo slave è pronto ad accettare dati dal master
- **BNR**#, asserisce uno stato di attesa quando il dispositivo indirizzato non può rispondere

## PIN DI DATI
È utilizzato per il trasferimento di dati
- **D#**, trasferisce 8 byte nel bus
- **DRDY#**, si asserisce quando D sta per trasferire i dati, così che tutti gli altri componenti sono informati della cosa
- **DBSY#**, viene usato per comunicare a tutti i dispositivi che il bus è occupato

## IL PIN DI RESET’#’
Viene usato per resettare la CPU in caso di problemi

> Differenza tra bus di controllo e arbitro del bus
> 
> - L’arbitro del bus si limita a gestire il traffico 
> - il bus di controllo gestisce tutto ciò che riguarda le operazioni che svolge il bus (l’invio, il ricevimento di dati, gestione degli indirizzi ecc..)

![](https://likingaxis.github.io/UNI/UNI/UTILITY/Pasted-image-20240411212614.png)

## Pipeline nel Pentium 4
Le CPU sono più veloci delle memorie centrali basate su DRAM e per questo è essenziale ottimizzare la pipeline per ottenere il massimo troughput dalla memoria per evitare attese della CPU

> Definizione troughput
> 
> Quantità di istruzioni in un determinato tempo

Per consentire l’uso della pipeline, le richieste di memoria del Pentium 4, chiamate **transazioni**, sono composte da sei stadi.
1. Fase di arbitraggio del bus;
    
2. Fase di richiesta;
    
3. Fase di segnalazione dell’errore;
    
4. Fase di investigazione (snoop);
    
5. Fase di risposta;
    
6. Fase dei dati.

![](https://likingaxis.github.io/UNI/UNI/UTILITY/Pasted-image-20240411222730.png)

## Intel Core I7
- 64 bit
- 4 core
- 45 nm
- 3,2 GHz
- Hyperthreaded, più thread simultanei, quindi più spezzettamenti di una singola istruzione che lavorano in parallelo
- Ha 3 livelli di cache e lo snooping ![](https://likingaxis.github.io/UNI/UNI/UTILITY/Pasted-image-20240412113510.png)

## UltraSPARC 3
- linea di processori RISC usata per server e workstation
- 130 nm 1,2 GHz
- due CPU CISC e RISC, non si possono confrontare tra loro
- La CPU poteva eseguire 4 istruzioni per ciclo di clock e aveva:
    - 6 pipeline interne:
        - 2 a 14- stadi per operazioni su numeri interi
        - 2 per operazioni a virgola mobile
        - 1 per operazioni di LOAD e STORE
        - 1 salti e branch del programma

## Micro controllore 8051
(***importante per gli esercizi sugli indirizzimenti e l’I/O** **a pagina 73***) 
È uno dei microcontrollori più diffusi, il microcontrollore è un apparato per svolgere compiti specifici programmabili e più economici di una normale CPU

- 40 pin con 16-bit di address, può indirizzare fino a 64KB di meoria, 8-bit per il bus dati
- ha 32 linee di I/O divise in 4 gruppi di 8 bit ciascuno
- i primi 7 a sinistra sono usati per interfacciarsi a memorie esterne
    1. la A viene usata per l’ indirizzamento alla memoria esterna
    2. la D è un pin dati a 8-bit per il trasporto dati
    3. RD si asserisce per indicare che deve fare una lettura
    4. WR si asserisce per indicare che deve fare una scrittura con la memoria esterna
    5. ALE indica la presenza di un indirizzo valido sul bus
    6. PSEN (Program Store Enable) si attiva quando viene usata una memoria esterna
    7. EA (External Access) può essere collegato:
	    - high usa sia la memoria interna che quella esterna
	    - low: usare solo quella esterna
- due cicli di clock esterni
- due priorità di interrupt diverse
- linee di I/O:
    - TXD usato per l’uscita seriale(uscita sequenziale)
    - RXD ricevere il segnale in modo sequenziale
    - ci sono anche 4 porte seriali sia di I/O bidirezionali ciascuna con 8- bit paralleli
- RST serve per resettare il chip ![](https://likingaxis.github.io/UNI/UNI/UTILITY/Pasted-image-20240412115302.png)


# Tipologie di bus
## Bus PCI
L'evoluzione del bus ISA. 
È **sincrono**, ossia scandisce le sue operazioni in un lasso di tempo (un ciclo di clock), con i dati che passano da un master a uno slave.

**![](https://lh7-us.googleusercontent.com/nSochZpFZtjV3WVqThbXcyMIG1hPIC5cL9u6esv9MLw7_FroRqfDdjbU-8L92mHeddLRw6T1PeM8RAzvW3RPUjqJkKpXXlQkermlFhX3U4kc2lZjorKEVo88qcrHPh503w-OkwG1Jtivab3zQQg8Tg)**

Rispetto all'EISA aveva una larghezza di banda maggiore, in modo da trasferire più dati, e inoltre le linee di indirizzi e dati sono multiplexate per ridurre i pin, così da rendere necessari solo 64 pin per i segnali di indirizzo e di dati.

I pin funzionano nel seguente modo:
1. nell'operazione di lettura il master immette l'indirizzo sul bus;
2. il master rimuove l'indirizzo dal bus e questo viene configurato per permettere il passaggio dei dati in direzione opposta;
3. lo slave, invia i dati richiesti al master tramite il PCI.
Quando invece si parla di scrittura il dato non viene riinviato al master, quindi cambia (di poco) il secondo passaggio.

## Bus PCI EXPRESS (PCIe)
Maggiore larghezza di banda (NON È L'EVOLUZIONE DEL PCI, È SOLO UNA MOSSA DI MARKETING).
Ha un **commutatore**, una sorta di gestore, che si collega sia  alle componenti che al chip bridge.
Commutatore-componenti sono collegate da un collegamento **point-to-point**.
Il commutatore prende i dati dalle componenti e tutti questi dati vengono inviati al chip bridge; successivamente il chip bridge invia i dati alla memoria e alla CPU.

**![](https://lh7-us.googleusercontent.com/k6rIo-q-8IJ--PJDQoPOSOsbH1RA2o4TqGW4hlca1k5eUU2H6tTurCLktpWQCsPgTBOPR5Dcc_qz0CC1uM3hTBDIlhjN5i04YaIvLK9vIPQutYK4qIA492e6qkXDIAhwPNwNfak5eT6g-oWR-5n7Ow)**

Il modello concettuale del bus PCIe è quello di un dispositivo che spedisce un pacchetto di dati a un altro dispositivo (con il bus PCI le componenti si sincronizzavano per inviare le informazioni al bridge, qui il bridge le riceve tutte insieme).

>#### Come è fatto questo pacchetto?
>Ha una serie di protocolli a strati, che gestisce diversi problemi a livelli distinti.
>
>>Che cos'è un protocollo?
>>Una serie di istruzioni e regole per permettere la comunicazione tra due parti (es. PC e server)
>
>La stratificazione di protocolli consente una progettazione modulare e flessibile.

### I livelli del PCIe (figura a)
1. **Livello fisico**: tratta lo spostamento dei bit da un mittente a un destinatario lungo una connessione punto-a-punto;
2. **Livello di trasmissione**: si occupa della trasmissione dei pacchetti, verifica che le informazioni passino in modo corretto da componente a commutatore;
3. **Livello di transazione**: gestisce le azioni del bus;
4. **Livello software**: interfaccia il sistema PCI Express al sistema operativo.

**![](https://lh7-us.googleusercontent.com/kBR4x0lbz-BOlXHOJm4a6AufnIU6qqAW_MHeKxLVkjNcjGruXBEhPMB_tzt_mooXKrdBL61TkApn6VGxSQLOyvIE0hq1z2_5Q24_RAEyz6or9lUzZq5W_NimGLk-O6wAwcUG3MYebjs5JiatvnTQYg)**

Nella figura b viene mostrata la suddivisione delle informazioni di un pacchetto.


# Universal Serial Bus
***PROBLEMA***: PCI e PCI Express sono troppo costosi per dispositivi lenti come mouse e tastiere.
Lo standard **USB** (Universal Serial Bus, “bus seriale universale”) nasce per risolvere tale problema.

Un sistema USB è composto da un hub principale (hub root), collegato al bus del sistema, che possiede delle prese per i cavi che connettono i dispositivi di I/O o per hub di espansione, in modo da fornire un maggior numero di prese. 

Il cavo consiste in quattro collegamenti: 
- due per i dati;
- uno per l’alimentazione (+5 volt);
- uno per la terra. 

>Cosa accade quando si collega un nuovo dispositivo?
>
>1. l’hub principale rileva l’evento e interrompe il sistema operativo; 
>2. il sistema operativo interroga il dispositivo per sapere di che periferica si tratta e di quanta banda ha bisogno;
>3. se il sistema operativo decide che c’è sufficiente larghezza di banda, gli assegna un indirizzo univoco (tra 1 e 127) e scarica nel dispositivo, oltre a questo indirizzo, anche altre informazioni necessarie a configurare i registri;
>In questo modo è possibile connettere nuovi dispositivi “al volo”, senza alcuna configurazione da parte dell’utente e senza dover installare una scheda ISA o PCI. 
>Le schede non inizializzate hanno indirizzo e possono dunque essere indirizzate. 
>
>Esattamente ogni 1,00 ± 0,05 ms, l’hub principale spedisce in broadcast (contemporaneamente) un nuovo frame (pacchetto) per mantenere sincronizzati tutti i dispositivi.
>
>La figura mostra una sequenza di quattro frame:
>**![](https://lh7-us.googleusercontent.com/tAOToTxlQ2xxgc55xn7ZRgFeCiaXi-Kj9HgZRk_EOTV2FuBg1oDZ1fUIs_beNTsAKELE3lp-MH0UmdWK7iXwmAJz4rZZ2UdLdP1BH8XIfySUdg_wcWlf6OlkApj3qtuEIZDap7GMmkZdM-mbQY9mJA)

USB supporta quattro tipi di frame: 
- controllo
	- usati per configurare i dispositivi, assegnare loro dei comandi e interrogarli sul loro stato
- isocroni
	- usati per i dispositivi funzionanti in tempo reale (come microfoni, altoparlanti o telefoni) che devono spedire o accettare dati a precisi intervalli temporali
- bulk
	- utilizzati per trasferimenti di grandi dimensioni per dispositivi che non richiedono un funzionamento in tempo reale, come le stampanti
- interrupt
	- necessari in quanto USB non supporta gli interrupt

Si è poi sviluppata un’altra versione di USB: **USB 2.0**, questo standard è simile al vecchio ed è retrocompatibile con esso, tranne per il fatto che raggiunge una velocità pari a 480 Mbps. 

# Interfacce
Un classico calcolatore di piccole e medie dimensioni è composto da:
- un chip della CPU
- alcuni chip di memoria
- alcuni controllori di I/O
Tutti connessi fra loro mediante un bus. 

## Interfacce di I/O
Sono chip molto comuni, attraverso cui il calcolatore comunica con il mondo esterno.
#### Chip UART 
(Universal Asynchronotis Receiver Transmitter)
È un chip che può leggere un byte da un bus di dati e generarlo in output, un bit alla volta, su una linea seriale per un terminale, oppure può ricevere input da un terminale. 
#### Chip USART 
(Universal Synchronous Asynchronotis Receiver Transmitters)
Possono gestire trasmissioni sincrone utilizzando vari protocolli, oltre a supportare tutte le funzionalità dei chip UART. 

## Interfacce PIO
Un esempio tipico di chip è il PIO (Parallel Input/Output), basato sul progetto originale Intel 8255A. Questo chip possiede 24 linee di I/O che possono essere interfacciate a qualsiasi dispositivo compatibile con TTL, come tastiere, interruttori, luci o stampanti. 

**![](https://lh7-us.googleusercontent.com/GVnIkCW5_0KSwuw_cXXLVSbwSi9oqhQK44Qi2ydYswX99qg5vkoMakMwOu1EApksGPF2Qzc0o2NtE3y9byZwmIxNEqNbsE4_aMfGployQAJLzQ0MpkRsr8gpUqai7auU00bVlGmv87m9OL2JQh9UrQ)**

In poche parole il programma della CPU può scrivere uno 0 o un 1 su ogni linea, oppure può leggere in input lo stato di ogni linea, garantendo così un’elevata flessibilità.









